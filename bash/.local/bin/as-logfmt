#!/usr/bin/env python3
# vim: ft=python
# Convert each line of input to logfmt, injecting fields such as time, process
# ID, name, hostname; and allowing the user to inject additional fields from
# either the command line, or within the input message.

import click
import os
import datetime
import socket
import re

def splitQuote( line: str ) -> [str]:
    pattern= re.compile(r'''((?:[^ "']|"[^"]*"|'[^']*')+)''')
    return pattern.split( line )[1::2]

def extractKeys( line: str ) -> str:
    keys= []
    tokens= splitQuote( line.strip() )
    for i in range( 1, len( tokens ) - 1 ):
        prev= tokens[ i - 1 ].strip()
        cur= tokens[ i ].strip()
        next= tokens[ i + 1 ].strip()

        if cur == '=':
            keys.append( f'''{prev}={next}''' )
    return " ".join( keys )

@click.command()
@click.option( "--context", "-c", help="Specify the context to use." )
@click.option( "--hostname", "-h", default=socket.gethostname(), help="Specify the hostname" )
@click.option( "--pid", "-p", default=os.getpid(), help="Specify the PID" )
@click.option( "--input", "-i", default="-", type=click.File( 'r' ), help="Specify input" )
@click.option( "--output", "-o", default="-", type=click.File( 'w' ), help="Specify output" )
def main(context: str, hostname: str, pid: str, input, output):
    """
    Convert each line of input to logfmt format. By default, that means just
    putting the entire line into a single key "message". However, if the line
    contains "key=value" pairs, those are copied to their own key/value entries
    in the output. Also, the keys "time", "context", "hostname", "message", and
    "pid" are reserved as they are populated automatically.

    For example, if you were to run the following:

        echo Hello world key=value foo=bar | as-logfmt --context=example

    the output would be e.g.:

        time="20250113T133643.123" context="example" hostname="myhost" pid="1234" key="value" foo="bar" message="Hello world key=value foo=bar"

    Tools such as lnav or splunk should be able to directly parse this output
    and provide rich query support.
    """

    for line in input:
        message= re.sub( '"', '\\"', line.strip() )
        print( f'time="{datetime.datetime.now()}" context="{context}" hostname="{hostname}" pid="{pid}" message="{message}" { extractKeys( line ) }', file=output )


if( __name__ == '__main__' ):
    main()
